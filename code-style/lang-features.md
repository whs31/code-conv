---
title: Возможности языка
tags:
  - cxx
---
### Rvalue-ссылки
Используйте `rvalue`-ссылки только в следующих случаях:
- Для определения **move**-конструктора и **move-assign** оператора
- Для определения методов, которые оставляют `this` в неинициализированном/невалидном состоянии. 
- Для поддержки **perfect-forwarding** в сочетании с `std::forward`.

### Friend
В общем случае разрешено использование "классов-друзей", с одним условием: *класс-друг должен быть объявлен в том же заголовочном файле, что и исходный класс.*

Примеры хорошего использования "друзей":
- Паттерн "*Строитель*"
- Юнит-тесты
- Фабрики 

Не стоит злоупотреблять ключевым словом `friend` - большинство классов должны взаимодействовать друг с другом только посредством публичных членов и функций.

### Исключения и обработка ошибок
Мы не используем исключения в С++.

Однако если сторонняя библиотека выбрасывает исключения (например, `Boost` или стандартная библиотека С++), хорошей практикой является их отлавливать.

> [!help] Примечание
> Если какая-либо функция, которую вы пишете, все же выбрасывает исключения вопреки всему (например, конструктор, в котором обработка ошибок может быть проблематичной), она **обязательно** должна быть помечена как `noexcept(false)`. Нарушение этого правила приведет к путанице в использовании вашего API.

##### Альтернативы
Если функция может вернуть значение, а может и не вернуть (например, оператор `[]` у вектора), то лучшим решением будет `std::optional`:
```cpp
template <typename T>
struct Vector {
  private:
    T* m_values;
    size_t m_size;		
    
  [[nodiscard]] auto get(size_t const index) -> optional<T> {
    if(index >= this->m_size)
      return std::nullopt;
    return this->m_values[index];
  }
};
```

Если функция может провалиться с каким-либо сообщением об ошибке, то правильнее всего использовать `std::expected`(C++23)/`tl::expected`/`lf::types::expected`:
```cpp
auto read_file(string_view path) -> expected<string, string> {
  using lf::Err;
  if(auto const p = std::filesystem::path(path); not exists(p))
    return Err("failed to open file at {}", path);
  auto const contents = /* ... */;
  return contents;
}
```

Если конструктор может провалиться, то корректнее всего использовать фабричные функции:
```cpp
class File {
  private:
    File();
  public:
    [[nodiscard]] static auto open() -> expected<void, string>;
};
```


### Noexcept
Функции, обозначенные как `noexcept` будут завершать работу *всей программы* с помощью `std::terminate`, если любое исключение покинет тело этой функции.

Например:
```
auto divide(int a, int b) noexcept {
	if(b == 0)
		throw std::invalid_argument("division by zero");
	return a / b;
}

auto const a = divide(1, 0); // приводит к завершению программы
```
- Обозначайте функцию как `noexcept` тогда, когда это уместно. 
- Никогда не обозначайте как `noexcept` те функции, которые могут при определенных обстоятельствах выбросить исключения.
- Не обозначайте функцию как `noexcept`, если в дальнейшем это может измениться и функция является частью публичного API.

Если функция выбрасывает исключения, то ее следует помечать как `noexcept(false)`. Это даст понимание тому, кто использует ваше API, что ему следует произвести отлавливание исключения.

### RTTI
**RTTI (Run-Time Type Information)** предоставляет возможность узнать тип объекта во времени выполнения.

Старайтесь избегать использования RTTI. Исключением является `dynamic_cast` и получения имени типа для логгирования.

Если у вас где-либо встречается использование `typeid` в условиях/циклах, то логика вашего кода сильно нарушена и ее стоит пересмотреть. Пример плохого кода:
```cpp
/* так делать не нужно! */
if(typeid(*ptr) == typeid(int))
  // ...
else if(typeid(*ptr) == typeid(float))
  // ...
else
  // ...
```

### Приведение типов
Используйте касты в стиле C++.

> [!fail] Замечание
> Никогда не используйте касты в стиле С (если только вы не пишете на чистом C).
> Пример плохого кода: `int a = (int)M_PI`.
> Исключением для этого правила является приведение к `void`.

> [!warning] Замечание
> Также не используйте касты через конструкторы (например, `int a = int(M_PI)`).

- Используйте `static_cast<T>` для приведения простых типов или для приведения указателя на родительский класс к указателю на подкласс.
- Используйте `const_cast<T>`, чтобы убрать квалификатор `const`.
- Используйте `reinterpret_cast<T>` для небезопасных приведений указателей, но делайте это с осторожностью.
- Используйте `dynamic_cast<T>` для приведений между родительскими и дочерними классами.
- Используйте `std::bit_cast<T>` для прямой побитовой конверсии типов **равного** размера (например, `uint64_t` в `double`).
- Используйте `qobject_cast<T>` там, где это необходимо. [Stackoverflow](https://stackoverflow.com/questions/43994584/what-is-qobject-cast)
- Используйте `boost::lexical_cast<T>` для приведения типов в строку и обратно. [Boost.Org](https://www.boost.org/doc/libs/1_42_0/libs/conversion/lexical_cast.htm)

### Потоки
К потокам относятся стандартные потоковые классы стандартной библиотеки С++ (например, `std::cout`, `std::cerr`, `std::ifstream`, `std::stringstream`).

Используйте следующую таблицу как пример для того, где необходимо использовать потоки:

| Операция            | Поток                                 | QT                                         | Прочие реализации                            | Предпочтение                                                  | Примечание                                               |
| ------------------- | ------------------------------------- | ------------------------------------------ | -------------------------------------------- | ------------------------------------------------------------- | -------------------------------------------------------- |
| Чтение файла        | `std::ifstream`                       | `QFile`                                    | `FILE*`, `std::FILE*`                        | ✅Потоки                                                       |                                                          |
| Запись в файл       | `std::ofstream`                       | `QFile`                                    | `FILE*`, `std::FILE*`                        | ✅Потоки                                                       |                                                          |
| Вывод в консоль     | `std::cout`, `std::cerr`, `std::clog` | `qDebug`, `qWarning`, `qInfo`, `qCritical` | `printf`, `perr`, библиотеки для логирования | ⛔Библиотеки для логгирования                                  | Используйте `spdlog` для логирования в консоль или файл. |
| Приведение к строке | `std::stringstream`                   | `QString`                                  | `boost::lexical_cast`                        | ❓`boost::lexical_cast`, если доступен, или стандартные потоки |                                                          |

Если вы определяете оператор `<<` для какого-либо из потоков (`std::ostream`, `QDebug`), убедитесь, что он выводит человеко-читаемую форму вашего типа.
> [!note] Примечание
> Хорошим тоном будет определить не только перегрузку для вашего потока, но и `fmt::formatter` для функции `fmt::format`. Подробнее: [ссылка](https://wgml.pl/blog/formatting-user-defined-types-fmt.html)

### Префиксный и постфиксный инкремент/декремент
Используйте префиксную форму инкремента и декремента, если только вам не нужна именно постфиксная форма.
Это дает незначительный выигрыш по производительности.
```cpp
for(auto i = 0; i < 100; i++) /* плохо */

for(auto i = 0; i < 100; ++i) /* хорошо */
```

### Использование const
Используйте спецификатор `const` всегда, где это возможно: в функциях, параметрах и переменных. Хорошей практикой будет всегда объявлять переменные как `const`, и убирать квалификатор позже, если это необходимо.

Некоторые выражения с квалификатором `const` на самом деле могут являться `constexpr`. Хорошей практикой будет преобразовывать такие выражения в `constexpr`.

Если параметр функции является константным, то в заголовочном файле его нужно объявить без спецификатора `const`, а в файле реализации - со спецификатором:
```cpp
/* meow.h */
class Cat {
	auto meow(int a) const -> void;
}

/* meow.cc */
auto Cat::meow(int const a) const -> void { /* ... */ }
```

#### Где помещать спецификатор?
Существует две равнозначные формы записи квалификатора `const`:
`1`
```cpp
auto const i = 1;
```

`2`
```cpp
const auto i = 1;
```

Семантический смысл обоих выражений равнозначен. Мы предпочитаем **вторую** форму записи, однако это требование не является обязательным.

### Выражения времени компиляции
В С++ выражения, выполняющиеся на этапе компиляции, обозначаются следующими ключевыми словами:
- `constexpr` - функция/выражение может потенциально быть выполнено на этапе компиляции, но это не гарантируется.
- `consteval` - функция может быть вызвана **только** на этапе компиляции и только на нем.
- `constinit` - гарантирует константную инициализацию для неконстантной переменной.
Использование данных ключевых слово активно поощряется и приводит к ускорению работы приложения. Примеры хорошего использования:

###### `constexpr`-переменные
```cpp
constexpr auto PI = 3.14f;
```

```cpp
constexpr auto buffer = std::array<uint8_t, 1024>{ /* ... */ };
```

###### `constexpr`-функции и конструкторы
```cpp
constexpr auto add(int const a, int const b) -> int { return a + b; }
```

```cpp
struct source_location {
  constexpr explicit source_location(string_view file, string_view line);
}
```

###### `consteval`-функции
```cpp
constexpr auto factorial(uint64_t n) -> uint64_t { 
  return n < 2 ? 1 : n * factorial(n - 1); 
}

consteval auto combination(uint64_t m, uint64_t n) -> uint64_t {
  return factorial(n) / factorial(m) / factorial(n - m);
}

// проверка на этапе компиляции
static_assert(factorial(6) == 720);
static_assert(combination(4, 8) == 70);

auto main() -> int {
  std::cout << factorial(6) << std::endl;      // OK
  std::cout << combination(4, 8) << std::endl; // Ошибка
}
```

Про наиболее распостраненное использование `constinit` можно прочитать здесь: [[scoping#Статические и локальные для потока переменные|Статические и локальные для потока переменные]]

### Целочисленные типы
Использование следующих ключевых слов является плохой практикой:
- `int`
- `char`
- `unsigned`
- `long`
- `short`
Все вышеперечисленные типы являются *платформозависимыми*, и их размер и знаковость отличается на разных платформах и компиляторах.

##### Альтернативы
Простая альтернатива - использование заголовочного файла `<cstdlib>`, который предоставляет следующие типы:
```cpp
int8_t
int16_t
int32_t
int64_t
uint8_t
uint16_t
uint32_t
uint64_t
uintptr_t
intptr_t
ptrdiff_t
size_t
```

В библиотеке **Leaf** также есть более короткие псевдонимы для данных типов:
```cpp
u8, u16, u32, u64
i8, i16, i32, i64
usize, isize

// находятся в пространстве имен lf::types
```