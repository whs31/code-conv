---
title: Возможности языка
tags:
  - cxx
---
### Rvalue-ссылки
Используйте `rvalue`-ссылки только в следующих случаях:
- Для определения **move**-конструктора и **move-assign** оператора
- Для определения методов, которые оставляют `this` в неинициализированном/невалидном состоянии. 
- Для поддержки **perfect-forwarding** в сочетании с `std::forward`.

### Friend
В общем случае разрешено использование "классов-друзей", с одним условием: *класс-друг должен быть объявлен в том же заголовочном файле, что и исходный класс.*

Примеры хорошего использования "друзей":
- Паттерн "*Строитель*"
- Юнит-тесты
- Фабрики 

Не стоит злоупотреблять ключевым словом `friend` - большинство классов должны взаимодействовать друг с другом только посредством публичных членов и функций.

### Исключения и обработка ошибок
Мы не используем исключения в С++.

Однако если сторонняя библиотека выбрасывает исключения (например, `Boost` или стандартная библиотека С++), хорошей практикой является их отлавливать.

> [!help] Примечание
> Если какая-либо функция, которую вы пишете, все же выбрасывает исключения вопреки всему (например, конструктор, в котором обработка ошибок может быть проблематичной), она **обязательно** должна быть помечена как `noexcept(false)`. Нарушение этого правила приведет к путанице в использовании вашего API.

##### Альтернативы
Если функция может вернуть значение, а может и не вернуть (например, оператор `[]` у вектора), то лучшим решением будет `std::optional`:
```cpp
template <typename T>
struct Vector {
  private:
    T* m_values;
    size_t m_size;		
    
  [[nodiscard]] auto get(size_t const index) -> optional<T> {
    if(index >= this->m_size)
      return std::nullopt;
    return this->m_values[index];
  }
};
```

Если функция может провалиться с каким-либо сообщением об ошибке, то правильнее всего использовать `std::expected`(C++23)/`tl::expected`/`lf::types::expected`:
```cpp
auto read_file(string_view path) -> expected<string, string> {
  using lf::Err;
  if(auto const p = std::filesystem::path(path); not exists(p))
    return Err("failed to open file at {}", path);
  auto const contents = /* ... */;
  return contents;
}
```

Если конструктор может провалиться, то корректнее всего использовать фабричные функции:
```cpp
class File {
  private:
    File();
  public:
    [[nodiscard]] static auto open() -> expected<void, string>;
};
```


### Noexcept
Функции, обозначенные как `noexcept` будут завершать работу *всей программы* с помощью `std::terminate`, если любое исключение покинет тело этой функции.

Например:
```
auto divide(int a, int b) noexcept {
	if(b == 0)
		throw std::invalid_argument("division by zero");
	return a / b;
}

auto const a = divide(1, 0); // приводит к завершению программы
```
- Обозначайте функцию как `noexcept` тогда, когда это уместно. 
- Никогда не обозначайте как `noexcept` те функции, которые могут при определенных обстоятельствах выбросить исключения.
- Не обозначайте функцию как `noexcept`, если в дальнейшем это может измениться и функция является частью публичного API.

Если функция выбрасывает исключения, то ее следует помечать как `noexcept(false)`. Это даст понимание тому, кто использует ваше API, что ему следует произвести отлавливание исключения.

### RTTI
**RTTI (Run-Time Type Information)** предоставляет возможность узнать тип объекта во времени выполнения.

Старайтесь избегать использования RTTI. Исключением является `dynamic_cast` и получения имени типа для логгирования.

Если у вас где-либо встречается использование `typeid` в условиях/циклах, то логика вашего кода сильно нарушена и ее стоит пересмотреть. Пример плохого кода:
```cpp
/* так делать не нужно! */
if(typeid(*ptr) == typeid(int))
  // ...
else if(typeid(*ptr) == typeid(float))
  // ...
else
  // ...
```

### Приведение типов
Используйте касты в стиле C++.

> [!fail] Замечание
> Никогда не используйте касты в стиле С (если только вы не пишете на чистом C).
> Пример плохого кода: `int a = (int)M_PI`.
> Исключением для этого правила является приведение к `void`.

> [!warning] Замечание
> Также не используйте касты через конструкторы (например, `int a = int(M_PI)`).

- Используйте `static_cast<T>` для приведения простых типов или для приведения указателя на родительский класс к указателю на подкласс.
- Используйте `const_cast<T>`, чтобы убрать квалификатор `const`.
- Используйте `reinterpret_cast<T>` для небезопасных приведений указателей, но делайте это с осторожностью.
- Используйте `dynamic_cast<T>` для приведений между родительскими и дочерними классами.
- Используйте `std::bit_cast<T>` для прямой побитовой конверсии типов **равного** размера (например, `uint64_t` в `double`).
- Используйте `qobject_cast<T>` там, где это необходимо. [Stackoverflow](https://stackoverflow.com/questions/43994584/what-is-qobject-cast)
- Используйте `boost::lexical_cast<T>` для приведения типов в строку и обратно. [Boost.Org](https://www.boost.org/doc/libs/1_42_0/libs/conversion/lexical_cast.htm)
