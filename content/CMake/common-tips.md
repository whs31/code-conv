---
title: 3. CMake - Написание правильного CMake-файла
tags:
  - cmake
---
### Основные правила
Файл `CMakeLists.txt` - это детальное описание того, как файлы исходного кода должны собираться в один или несколько бинарных файлов (т.е. исполняемых файлов или библиотек).

Как было сказано в главе "[[commands|Основные команды]]", любой правильно написанный CMake-файл должен содержать 3 секции:
- Конфигурация
- Сборка
- Экспорт

Так как иногда в рамках разработки или специализированной поставки требуется использование CMake без связки с пакетным менеджером, то всегда должна присутствовать возможность равноценного использования вашего проекта как в виде подпроекта (*subdirectory*), так и в виде полноценной *экспортированной библиотеки*.

Так как одной из основных целевых ОС у нас является *Astra Linux 1.7*, версия CMake ограничена сверху версией **3.16**.

### Создание проекта
#### Ограничение версии CMake
Любой CMake-файл должен начинаться со следующей строчки:
```cmake
cmake_minimum_required(VERSION 3.16)
```

> [!note]
> Как указано выше, версия CMake на *Astra Linux* ограничена сверху версией **3.16**.
> Однако, мы указываем только ограничение снизу, так как большинство разработчиков используют ОС, на которых версия CMake выше чем **3.16**, и ограничение сверху вызовет проблемы с разработкой такого проекта.
> 
> Если вам все же нужно ограничить версию CMake сверху, то для этого используется следующий синтаксис:
> ```cmake
> cmake_minimum_required(VERSION 3.16...3.21)
> ```

#### Защита от повторного включения
Хорошей практикой является в любом файле помещать следующую строчку:
```cmake
include_guard(GLOBAL)
```

Эта директива эквивалентна директиве препроцессора `#pragma once` в С++. Она позволяет одновременно существовать нескольким CMake-файлам с целями, имеющими одинаковые имена в дереве зависимостей проекта.

> [!tip]
> Если вы используете *Astra Linux 1.6* и ниже, то данную директиву можно заменить на следующий код:
> ```cmake
> if(TARGET ${PROJECT_NAME})
>   return()
> endif()
> ```
> Помещать этот код следует после объявления проекта, а не до, как в случае с `include_guard(GLOBAL)`.

#### Проект
Перед объявлением проекта вам необходимо выбрать три имени:
- Название проекта;
- Название цели/целей сборки;
- Пространство имен, которому эти цели принадлежат.
Они потребуются при объявлении целей сборки и в секции экспорта.

Например, если вы делаете модуль, вычисляющий собственные значения матриц для большой библиотеки, которая предоставляет различные математические функции и называется "*math*", то хорошими именами будут:
- *math-eigen* - название проекта;
- *eigen* - название цели сборки;
- *math::* - пространство имен.
При правильном соблюдении этих правил ваши библиотеки всегда будут доступны извне под корректным именем вне зависимости, используете ли вы подпроекты, пакетный менеджер или экспорт в системные директории.

Объявление проекта выглядит так:
```cmake
project(math-eigen                     # название проекта
  VERSION 1.0.0                        # версия проекта
  DESCRIPTION "Eigen math library"     # краткое описание проекта
  HOMEPAGE_URL "github.com/math/eigen" # домашняя страница (напр. репозиторий)
  LANGUAGES C CXX                      # используемые языки
)
set(PROJECT_NAMESPACE "math::")
```

> [!warning]
> В поле `LANGUAGES` должны находится только те языки, которые поддерживаются *CMake*.
> Если ваш проект содержит код на JavaScript или QML, не нужно вставлять эти языки в это поле.
> Поддерживаемые языки:
> - C, CXX
> - Fortran 
> - CUDA
> - CSharp
> - Swift
> - OBJC, OBJCXX
> - ASM, ASM_NASM, ASM_MARMASM, ASM_MASM, ASM-ATT
> - HIP, ISPC

> [!important]
> Если вы также планируете использовать пакетный менеджер, то убедитесь, что версия вашего проекта в CMake и в файле пакетного менеджера (напр. в *conanfile.py*) совпадает.
> Этот процесс можно автоматизировать. Подробнее: ((здесь будет ссылка)).

#### Стандарт С, С++
Всегда указывайте [[../C++/cxx-version|минимальный стандарт С++]], который используется в проекте. Корректный способ сделать это:
```cmake
if(NOT CMAKE_CXX_STANDARD)      # не будет перезаписывать уже заданный стандарт
  set(CMAKE_CXX_STANDARD 20)    # c++20
  set(CMAKE_CXX_STANDARD_REQUIRED ON)
  set(CMAKE_CXX_EXTENSIONS OFF) # выключает нестандартные расширения 

  # опциональный вывод стандарта в консоль
  message(STATUS "[${PROJECT_NAME}] c++ standard: ${CMAKE_CXX_STANDARD}")
endif()  
```

Также хорошей практикой будет позаботиться о пользователях MSVC, добавив следующую строчку после указания стандарта:
```cmake
if("${CMAKE_GENERATOR}" MATCHES "^Visual Studio")
  set(CMAKE_GENERATOR_PLATFORM "x64" CACHE STRING "" FORCE)
endif()
```

#### Настройка окружения
##### fPIC
Всегда включайте *fPIC*, если не собираете приложение или shared-only библиотеку. Подробнее про *fPIC* можно прочитать здесь: [ссылка](https://habr.com/ru/companies/badoo/articles/324616/).

Для включения используйте следующую встроенную опцию CMake:
```cmake
set(CMAKE_POSITION_INDEPENDENT_CODE ON)

# опциональный вывод информации об этом в консоль cmake:
message(STATUS "[${PROJECT_NAME}] fpic status: ${CMAKE_POSITION_INDEPENDENT_CODE}")
```

##### MOC/RCC
В проектах, использующих Qt, необходимо явно включать препроцессинг с помощью утилит `moc`, `rcc` и, опционально, `uic`.
Для этого используйте следующие опции:
```cmake
set(CMAKE_AUTOMOC ON)    # включает moc
set(CMAKE_AUTORCC ON)    # включает rcc
set(CMAKE_AUTOUIC ON)    # включает uic (если используются qt widgets)
```

#### Поиск зависимостей
Для менеджмента зависимостей используются 4 способа:
- Поиск уже установленных библиотек в системе;
- Поиск уже установленных библиотек в реестре пакетного менеджера;
- Включение сторонних библиотек в виде подпроектов с исходным кодом (*subdirectory*);
- Включение сторонних библиотек с помощью модуля *FetchContent*.

Давайте рассмотрим плюсы и минусы каждого решения:

| Возможность             | Системные библиотеки | Пакетный менеджер | Подпроекты, сабмодули | *FetchContent* |
| ----------------------- | -------------------- | ----------------- | --------------------- | -------------- |
| Отсутствие рекомпиляции | ✅                    | ✅                 | ❌                     | ❌              |
