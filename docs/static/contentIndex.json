{"cxx-version":{"title":"Используемый стандарт","links":[],"tags":["cxx"],"content":"Используемый стандарт С++, компилятор и расширения\nСтандарт C++\nНа данный момент основным используемым стандартом является C++20 с незначительными отсутствующими частями стандартной библиотеки.\n\nДля разработчиков под Astra Linux SE 1.6 максимально высоким стандартом является C++14 без расширений.\n\nНе допускается использование следующих заголовочных файлов стандартной библиотеки:\n\nformat - вместо std::format рекомендуется использовать fmt::format из библиотеки fmt (доступна в нашем репозитории)\nsource_location - вместо std::source_location рекомендуется использовать библиотеку Boost.\n\nМодули из С++20 в данный момент не поддерживаются используемой версией CMake, поэтому их использование также запрещено (в т.ч. замена директивы #include на ключевое слово import)\nКомпилятор\nОсновным используемым компилятором является GCC 10.2.0. В роли резервного компилятора выступает Clang 15.\nПравильно написанная библиотека/приложение должно компилироваться всеми основными компиляторами (GCC → Clang → MSVC в порядке убывания приоритета)\nНестандартные расширения компилятора\nАтрибуты GCC\nАтрибуты (ключевое слово __attribute__) находятся под запретом, так как не поддерживаются компиляторами, отличными от GCC.\nКак заменить __attribute__((constuctor))?\nЭтот атрибут обычно используется для автоматического вызова какой-либо свободной функции при линковке.\nНеправильный код\nauto __attribute__((constructor)) print_version() -&gt; void {\n\tfmt::print(&quot;loaded library {} version {}.{}&quot;, \n\t\tPROJECT_NAME, \n\t\tPROJECT_VERSION_MAJOR,\n\t\tPROJECT_VERSION_MINOR\n\t);\n}\nДанный код не будет скомпилирован компиляторами MSVC и, потенциально, Clang.\nПравильный код\nstruct constructor {\n\texplicit constructor(void (*f)(void)) { f(); }\n};\n \nstatic constructor print_version(+[]() -&gt; void {\n\tfmt::print(&quot;loaded library {} version {}.{}&quot;, \n\t\tPROJECT_NAME, \n\t\tPROJECT_VERSION_MAJOR,\n\t\tPROJECT_VERSION_MINOR\n\t);\n});\nСемантический смысл остается тем же, но этот вариант скомпилируется любым из современных компиляторов С++.\nЕсли вам требуется вызывать constructor часто, то struct constructor можно параметризировать через шаблон.\nКак заменить __attribute__((packed))?\nЭтот атрибут используется для того, чтобы убрать паддинг (отступ) между членами внутри структуры.\nНеправильный код\nstruct Data \n{\n\tint a;\n\tbool b;\n\tfloat c;\n\tlong long d;\n} __attribute__((packed));\nПравильный код\n#pragma pack(push, 1)\nstruct [[gnu::packed]] Data \n{\n\tint a;\n\tbool b;\n\tfloat c;\n\tlong long d;\n};\n#pragma pack(pop)\nВстроенные функции компиляторов (интринсики)\nЕсли интринсик предоставляет функционал, который помогает компилятору в оптимизации кода, или же необходим для корректной работы программы (напр. __declspec), то его использование должно быть абстрагировано с помощью макроса или функции.\nВ остальных случаях интринсики ведут к нарушениям кроссплатформенности программы и их использование осуждается.\nЕсли необходимо использование интринсика\nНапример, для явного указания, что та или иная ветвь потока управления в коде никогда не будет выполнена, существует интринсик GCC __builtin_unreachable.\nНеправильный код\nbool a = false;\nswitch(static_cast&lt;char&gt;(a)) {\n\tcase 0: /* ... */ break;\n\tcase 1: /* ... */ break;\n\tdefault: __builtin_unreachable();\n}\nПравильный код\n[[noreturn]] auto unreachable() -&gt; void {\n\t#if defined(_MSC_VER) &amp;&amp;!defined(__clang__) // MSVC\n\t__assume(false);\n\t#else \n\t__builtin_unreachable();\n\t#endif\n}\n \nbool a = false;\nswitch(static_cast&lt;char&gt;(a)) {\n\tcase 0: /* ... */ break;\n\tcase 1: /* ... */ break;\n\tdefault: ::unreachable();\n}\nЕсли интринсик нужен для импорта/экспорта в динамической библиотеке\nДля того, чтобы символы корректно линковались в динамических библиотеках, их необходимо помечать как экпортируемые. Для этого используется комбинация __declspec(dllexport)/__declspec(dllimport).\nПример корректного кода для публичного заголовочного файла в библиотеке:\nglobal.h\n#if defined(_WIN32)\n# if defined(TEST_LIBRARY)\n#  define TEST_EXPORT __declspec(dllexport)\n# elif defined(TEST_STATIC_LIBRARY)\n#  define TEST_EXPORT\n# else\n#  define TEST_EXPORT __declspec(dllimport)\n# endif\n#else\n# define TEST_EXPORT\n#endif\ntest.h\n#include &lt;global.h&gt;\n \nTEST_EXPORT auto meow() -&gt; void;\n \nclass TEST_EXPORT Cat { /* ... */ };\nstruct TEST_EXPORT Dog { /* ... */ };\nОсобые директивы препроцессора\nНестандартные директивы препроцессора запрещены к использованию. В их число входит:\n\n#pragma - в т.ч. #pragma omp, pragma region и т. д.\n#elifdef\n#include_next\n\n\n\n                  \n                  Замечание \n                  \n                \nДиректива #pragma once разрешена и поощряется, так как поддерживается любым современным компилятором и является полностью кроссплатформенной.\n\nПрочие нестандартные расширения языка\nТакже запрещены:\n\nАссемблерные вставки\nМакросы __COUNTER__, __PRETTY_FUNCTION__\nElvis-operator (?:): Wikipedia\n"},"formatting":{"title":"Форматирование кода","links":[],"tags":["cxx"],"content":"Отступы и табуляция\nКак и Google, мы используем 2 пробела на отступ.\nСекции области видимости в классах также должны иметь дополнительный отступ в 2 пробела.\nЧлены пространства имен также должны иметь отступ в 2 пробела.\nПример:\nnamespace ns {\n  class Cat {\n    public:\n      auto meow() -&gt; void;\n    private:\n      void* data;\n  };\n}"},"functions":{"title":"Функции","links":[],"tags":["cxx"],"content":"Входные и выходные параметры\n\nМы никогда не используем указатели как выходные параметры функции.\nВсе аргументы, передаваемые в функцию, являются ее входными параметрами.\nЕдинственным исключением является передача в функцию изменяемой ссылки для проведения операции над этой ссылкой.\nМы не возвращаем из функции значения с помощью ключевого слова throw.\n\nАргументы по умолчанию\nМы не используем аргументы по умолчанию, так как это требует от пользователя функции производить дополнительную проверку ее сигнатуры. Аргументы по умолчанию в виртуальных функциях ведут к неопределенному поведению.\nЕсли требуется указать опциональный аргумент, используйте std::optional для этой цели.\nСинтаксис объявления функции\nМы используем современный синтаксис объявления функции во всех случаях (об исключениях к этому правилу ниже).\nМы также обязательно добавляем атрибут [[nodiscard]], если функция возвращает значение.\nПример правильно объявленной функции:\n[[nodiscard]] auto add(int a, int b) -&gt; int;\nВ случае работы с Qt-кодом (например, Q_INVOKABLE или сигналы), мы используем стандартный синтаксис объявления функции, так как moc до версии 6.5 не поддерживает новый синтаксис. В этом случае мы отключаем clang-tidy и ReSharper комментарием.\nПример:\n// NOLINTBEGIN\n// ReSharper disable All\nclass QMLClass : public QObject {\n  Q_OBJECT\n  \n  public: \n    Q_INVOKABLE void test();\n \n  signals:\n    void testSuccess();\n    void testFailed();\n};\n// ReSharper restore All\n// NOLINTEND"},"headers":{"title":"Заголовочные файлы","links":[],"tags":["cxx"],"content":"\nОбщая информация\nРасширения файлов\nHeader-guard\r\n- Неправильный код\r\n- Правильный код\nВключение других заголовочных файлов\r\n- Неправильный код\r\n- Правильный код\nОбъявления наперед (forward-declarations)\nПорядок включений\n\nОбщая информация\nКаждый файл исходного кода (.cc) должен иметь ассоциированный с собой заголовок.\nДля этого правила есть исключения, например, в случае с юнит-тестами или файлами с точкой входа в программу (функцией main).\nМы используем для включения только символы &lt;, &gt;. Кавычки не рекомендуются для использования, если в этом нет крайней необходимости.\n#include &lt;cat/meow.h&gt; // 😊 правильно\n#include &quot;cat/meow.h&quot; // 😡 неправильно\nРасширения файлов\nЗаголовочные файлы должны иметь расширение .h. Допускается использования расширения .hh для файлов, не являющихся частью API, то есть не экспортируемых за пределы библиотеки.\nHeader-guard\nКаждый заголовочный файл должен иметь header-guard в виде директивы #pragma once.\nНеправильный код\n#ifndef MEOW_HEADER\n#define MEOW_HEADER\n \n/* ... */\n \n#endif // MEOW_HEADER\nПравильный код\n#pragma once\n \n/* ... */\nВключение других заголовочных файлов\nЕсли файл использует какой-либо символ из стороннего заголовочного файла, то он должен напрямую включать этот заголовочный файл. Это единственное условие для включения заголовочных файлов и в любом другом случае включение производиться не должно.\nПримеры:\nНеправильный код\n#include &lt;iostream&gt;\n \nstd::string a = &quot;qwe&quot;;\nstd::cout &lt;&lt; a &lt;&lt; std::endl;\nДанный код может привести к ошибке компиляции на некоторых платформах.\nПравильный код\n#include &lt;string&gt;\n#include &lt;iostream&gt;\n \nstd::string a = &quot;qwe&quot;;\nstd::cout &lt;&lt; a &lt;&lt; std::endl;\nОбъявления наперед (forward-declarations)\nИспользуйте объявления наперед там, где это возможно.\n\n\n                  \n                  Предупреждение \n                  \n                \nНе стоит использовать объявления наперед в случае с шаблонными типами и символами из пространства имен std::.\n\nВ случае с заголовочными файлами из стандартной библиотеки поощряется использование стандартных заголовков для объявления наперед, если такие существуют. Например, вместо &lt;iostream&gt; включать &lt;iosfwd&gt; (cppreference).\nПорядок включений\nРекомендуется использовать следующий порядок включений:\n\nЗаголовки языка C (&lt;cstdlib&gt;, &lt;cstring&gt;)\nЗаголовки стандартной библиотеки C++ (&lt;iostream&gt;, &lt;string&gt;)\nЗаголовки ОС (&lt;unistd.h&gt;, &lt;windows.h&gt;)\nЗаголовки системных библиотек (&lt;python.h&gt;, &lt;curl.h&gt;)\nЗаголовки сторонних библиотек (&lt;gtest/gtest.h&gt;, &lt;leaf/utils/rtti.h&gt;)\nЗаголовки Qt. Для заголовков Qt доступны 2 равнозначных стиля включения:\n\nВключение по полному имени и модулю: &lt;QtCore/QString&gt;, &lt;QtWidgets/QApplication\nВключение по исходному заголовочному файлу: &lt;qstring.h&gt;, &lt;qobject.h&gt;\n\n\nПубличные заголовки текущей библиотеки/проекта: &lt;cats/meow.h&gt;\nПриватные заголовки текущей библиотеки/проекта: &lt;meow_impl.h&gt;\nУсловные включения (т.е. обернутые в #if/#endif)\n\nПример\n#include &lt;cstdlib&gt;\n#include &lt;cstdbool&gt;\n#include &lt;string&gt;\n#include &lt;iostream&gt;\n#include &lt;windows.h&gt;\n#include &lt;python.h&gt;\n#include &lt;gtest/gtest.h&gt;\n#include &lt;leaf/leaf.h&gt;\n#include &lt;leaf/utils/rtti.h&gt;\n#include &lt;qcoreapplication.h&gt;\n#include &lt;qobject.h&gt;\n#include &lt;qqmlapplicationengine.h&gt;\n#include &lt;this_project/cat/meow.h&gt;\n#include &lt;this_project/dog/bark.h&gt;\n#include &lt;cat/meow_p.h&gt;\n#include &lt;dog/bark_p.h&gt;\n \n#if defined(CATS)\n# include &lt;this_project/cat/purr.h&gt;\n#endif\n\n\n                  \n                  Замечание \n                  \n                \nНе  допускается использование относительных путей в директиве #include.\n"},"index":{"title":"Radar MMS C++ Style Guide","links":["cxx-version","headers","scoping","functions","lang-features","naming","formatting"],"tags":["c","cxx","cmake","docs","code-style"],"content":"Содержание\nСтандарт С++\n\nИспользуемый стандарт\nКомпилятор\nНестандартные расширения языка\n\nЗаголовочные файлы\n\nРасширения файлов\nЗащита от повторного включения\nВключение файлов\nОбъявления наперед\nПорядок включений\n\nОбласть видимости\n\nПространства имен\nСтатические функции\nЛокальные переменные\nstatic и thread_local переменные\n\nФункции\n\nВходные и выходные параметры\nАргументы по умолчанию\nСинтаксис объявления функции\n\nВозможности C++\n\nRvalue-ссылки\nFriend\nИсключения и обработка ошибок\nNoexcept\nRTTI\nПриведение типов\nПотоки\nдекремент\nИспользование const\nВыражения времени компиляции\nЦелочисленные типы\nМакросы\nНулевые типы\nAuto\n\nСоглашение по именованию\n\nФайлы\nТипы\nПеременные и константы\nФункции\nПространства имен\nПеречисления\nМакросы\nНазвания библиотек\n\nФорматирование кода\n\nОтступы и табуляция\n"},"lang-features":{"title":"Возможности языка","links":["scoping"],"tags":["cxx"],"content":"Rvalue-ссылки\nИспользуйте rvalue-ссылки только в следующих случаях:\n\nДля определения move-конструктора и move-assign оператора\nДля определения методов, которые оставляют this в неинициализированном/невалидном состоянии.\nДля поддержки perfect-forwarding в сочетании с std::forward.\n\nFriend\nВ общем случае разрешено использование “классов-друзей”, с одним условием: класс-друг должен быть объявлен в том же заголовочном файле, что и исходный класс.\nПримеры хорошего использования “друзей”:\n\nПаттерн “Строитель”\nЮнит-тесты\nФабрики\n\nНе стоит злоупотреблять ключевым словом friend - большинство классов должны взаимодействовать друг с другом только посредством публичных членов и функций.\nИсключения и обработка ошибок\nМы не используем исключения в С++.\nОднако если сторонняя библиотека выбрасывает исключения (например, Boost или стандартная библиотека С++), хорошей практикой является их отлавливать.\n\n\n                  \n                  Примечание \n                  \n                \nЕсли какая-либо функция, которую вы пишете, все же выбрасывает исключения вопреки всему (например, конструктор, в котором обработка ошибок может быть проблематичной), она обязательно должна быть помечена как noexcept(false). Нарушение этого правила приведет к путанице в использовании вашего API.\n\nАльтернативы\nЕсли функция может вернуть значение, а может и не вернуть (например, оператор [] у вектора), то лучшим решением будет std::optional:\ntemplate &lt;typename T&gt;\nstruct Vector {\n  private:\n    T* m_values;\n    size_t m_size;\t\t\n    \n  [[nodiscard]] auto get(size_t const index) -&gt; optional&lt;T&gt; {\n    if(index &gt;= this-&gt;m_size)\n      return std::nullopt;\n    return this-&gt;m_values[index];\n  }\n};\nЕсли функция может провалиться с каким-либо сообщением об ошибке, то правильнее всего использовать std::expected(C++23)/tl::expected/lf::types::expected:\nauto read_file(string_view path) -&gt; expected&lt;string, string&gt; {\n  using lf::Err;\n  if(auto const p = std::filesystem::path(path); not exists(p))\n    return Err(&quot;failed to open file at {}&quot;, path);\n  auto const contents = /* ... */;\n  return contents;\n}\nЕсли конструктор может провалиться, то корректнее всего использовать фабричные функции:\nclass File {\n  private:\n    File();\n  public:\n    [[nodiscard]] static auto open() -&gt; expected&lt;File, string&gt;;\n};\nabsl::Status\nДопускается также использование класса Status из открытой библиотеки Abseil от Google.\nНапример:\n#include &lt;absl/status&gt;\n \nclass File {\n  private:\n    File();\n  public:\n    [[nodiscard]] static auto open() -&gt; absl::StatusOr&lt;File&gt; {\n      if(/* ... */)\n        return absl::NotFoundError(&quot;bad file path&quot;);\n      return absl::OkStatus(/* ... */);\n    }\n}\nПодробнее можно прочитать здесь: ссылка.\nNoexcept\nФункции, обозначенные как noexcept будут завершать работу всей программы с помощью std::terminate, если любое исключение покинет тело этой функции.\nНапример:\nauto divide(int a, int b) noexcept {\n\tif(b == 0)\n\t\tthrow std::invalid_argument(&quot;division by zero&quot;);\n\treturn a / b;\n}\n\nauto const a = divide(1, 0); // приводит к завершению программы\n\n\nОбозначайте функцию как noexcept тогда, когда это уместно.\nНикогда не обозначайте как noexcept те функции, которые могут при определенных обстоятельствах выбросить исключения.\nНе обозначайте функцию как noexcept, если в дальнейшем это может измениться и функция является частью публичного API.\n\nЕсли функция выбрасывает исключения, то ее следует помечать как noexcept(false). Это даст понимание тому, кто использует ваше API, что ему следует произвести отлавливание исключения.\nRTTI\nRTTI (Run-Time Type Information) предоставляет возможность узнать тип объекта во времени выполнения.\nСтарайтесь избегать использования RTTI. Исключением является dynamic_cast и получения имени типа для логгирования.\nЕсли у вас где-либо встречается использование typeid в условиях/циклах, то логика вашего кода сильно нарушена и ее стоит пересмотреть. Пример плохого кода:\n/* так делать не нужно! */\nif(typeid(*ptr) == typeid(int))\n  // ...\nelse if(typeid(*ptr) == typeid(float))\n  // ...\nelse\n  // ...\nПриведение типов\nИспользуйте касты в стиле C++.\n\n\n                  \n                  Замечание \n                  \n                \nНикогда не используйте касты в стиле С (если только вы не пишете на чистом C).\nПример плохого кода: int a = (int)M_PI.\nИсключением для этого правила является приведение к void.\n\n\n\n                  \n                  Замечание \n                  \n                \nТакже не используйте касты через конструкторы (например, int a = int(M_PI)).\n\n\nИспользуйте static_cast&lt;T&gt; для приведения простых типов или для приведения указателя на родительский класс к указателю на подкласс.\nИспользуйте const_cast&lt;T&gt;, чтобы убрать квалификатор const.\nИспользуйте reinterpret_cast&lt;T&gt; для небезопасных приведений указателей, но делайте это с осторожностью.\nИспользуйте dynamic_cast&lt;T&gt; для приведений между родительскими и дочерними классами.\nИспользуйте std::bit_cast&lt;T&gt; для прямой побитовой конверсии типов равного размера (например, uint64_t в double).\nИспользуйте qobject_cast&lt;T&gt; там, где это необходимо. Stackoverflow\nИспользуйте boost::lexical_cast&lt;T&gt; для приведения типов в строку и обратно. Boost.Org\n\nПотоки\nК потокам относятся стандартные потоковые классы стандартной библиотеки С++ (например, std::cout, std::cerr, std::ifstream, std::stringstream).\nИспользуйте следующую таблицу как пример для того, где необходимо использовать потоки:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nОперацияПотокQTПрочие реализацииПредпочтениеПримечаниеЧтение файлаstd::ifstreamQFileFILE*, std::FILE*✅ПотокиЗапись в файлstd::ofstreamQFileFILE*, std::FILE*✅ПотокиВывод в консольstd::cout, std::cerr, std::clogqDebug, qWarning, qInfo, qCriticalprintf, perr, библиотеки для логирования⛔Библиотеки для логгированияИспользуйте spdlog для логирования в консоль или файл.Приведение к строкеstd::stringstreamQStringboost::lexical_cast❓boost::lexical_cast, если доступен, или стандартные потоки\nЕсли вы определяете оператор &lt;&lt; для какого-либо из потоков (std::ostream, QDebug), убедитесь, что он выводит человеко-читаемую форму вашего типа.\n\n\n                  \n                  Примечание \n                  \n                \nХорошим тоном будет определить не только перегрузку для вашего потока, но и fmt::formatter для функции fmt::format. Подробнее: ссылка\n\nПрефиксный и постфиксный инкремент/декремент\nИспользуйте префиксную форму инкремента и декремента, если только вам не нужна именно постфиксная форма.\nЭто дает незначительный выигрыш по производительности.\nfor(auto i = 0; i &lt; 100; i++) /* плохо */\n \nfor(auto i = 0; i &lt; 100; ++i) /* хорошо */\nИспользование const\nИспользуйте спецификатор const всегда, где это возможно: в функциях, параметрах и переменных. Хорошей практикой будет всегда объявлять переменные как const, и убирать квалификатор позже, если это необходимо.\nНекоторые выражения с квалификатором const на самом деле могут являться constexpr. Хорошей практикой будет преобразовывать такие выражения в constexpr.\nЕсли параметр функции является константным, то в заголовочном файле его нужно объявить без спецификатора const, а в файле реализации - со спецификатором:\n/* meow.h */\nclass Cat {\n\tauto meow(int a) const -&gt; void;\n}\n \n/* meow.cc */\nauto Cat::meow(int const a) const -&gt; void { /* ... */ }\nГде помещать спецификатор?\nСуществует две равнозначные формы записи квалификатора const:\n1\nauto const i = 1;\n2\nconst auto i = 1;\nСемантический смысл обоих выражений равнозначен. Мы предпочитаем первую форму записи, однако это требование не является обязательным.\nВыражения времени компиляции\nВ С++ выражения, выполняющиеся на этапе компиляции, обозначаются следующими ключевыми словами:\n\nconstexpr - функция/выражение может потенциально быть выполнено на этапе компиляции, но это не гарантируется.\nconsteval - функция может быть вызвана только на этапе компиляции и только на нем.\nconstinit - гарантирует константную инициализацию для неконстантной переменной.\nИспользование данных ключевых слово активно поощряется и приводит к ускорению работы приложения. Примеры хорошего использования:\n\nconstexpr-переменные\nconstexpr auto PI = 3.14f;\nconstexpr auto buffer = std::array&lt;uint8_t, 1024&gt;{ /* ... */ };\nconstexpr-функции и конструкторы\nconstexpr auto add(int const a, int const b) -&gt; int { return a + b; }\nstruct source_location {\n  constexpr explicit source_location(string_view file, string_view line);\n}\nconsteval-функции\nconstexpr auto factorial(uint64_t n) -&gt; uint64_t { \n  return n &lt; 2 ? 1 : n * factorial(n - 1); \n}\n \nconsteval auto combination(uint64_t m, uint64_t n) -&gt; uint64_t {\n  return factorial(n) / factorial(m) / factorial(n - m);\n}\n \n// проверка на этапе компиляции\nstatic_assert(factorial(6) == 720);\nstatic_assert(combination(4, 8) == 70);\n \nauto main() -&gt; int {\n  std::cout &lt;&lt; factorial(6) &lt;&lt; std::endl;      // OK\n  std::cout &lt;&lt; combination(4, 8) &lt;&lt; std::endl; // Ошибка\n}\nПро наиболее распостраненное использование constinit можно прочитать здесь: Статические и локальные для потока переменные\nЦелочисленные типы\nИспользование следующих ключевых слов является плохой практикой:\n\nint\nchar\nunsigned\nlong\nshort\nВсе вышеперечисленные типы являются платформозависимыми, и их размер и знаковость отличается на разных платформах и компиляторах.\n\nАльтернативы\nПростая альтернатива - использование заголовочного файла &lt;cstdint&gt;, который предоставляет следующие типы:\nint8_t\nint16_t\nint32_t\nint64_t\nuint8_t\nuint16_t\nuint32_t\nuint64_t\nuintptr_t\nintptr_t\nptrdiff_t\nsize_t\nВ библиотеке Leaf также есть более короткие псевдонимы для данных типов:\nnamespace leaf::types {\n  using u8 = uint8_t;       ///&lt; 8-bit беззнаковое целое\n  using u16 = uint16_t;     ///&lt; 16-bit беззнаковое целое\n  using u32 = uint32_t;     ///&lt; 32-bit беззнаковое целое\n  using u64 = uint64_t;     ///&lt; 64-bit беззнаковое целое\n  using i8 = int8_t;        ///&lt; 8-bit знаковое целое\n  using i16 = int16_t;      ///&lt; 16-bit знаковое целое\n  using i32 = int32_t;      ///&lt; 32-bit знаковое целое\n  using i64 = int64_t;      ///&lt; 64-bit знаковое целое\n  using usize = size_t;     ///&lt; Беззнаковое целое размером с указатель на `void`\n  using isize = intptr_t;   ///&lt; Знаковое целое размером с указатель на `void`\n  using f32 = float;        ///&lt; 32-bit число с плавающей точкой (`float`)\n  using f64 = double;       ///&lt; 64-bit число с плавающей точкой (`double`)\n  using f128 = long double; ///&lt; 128-bit число с плавающей точкой (`long double`)\n}\n32- и 64- битные архитектуры\nВаш код должен работать одинаково и на 32-разрядных, и на 64-разрядных архитектурах.\nОбщие советы для достижения этой цели:\n\nИспользуйте size_t для индексирования по коллекциям\nИспользуйте intptr_t/uintptr_t в случаях, когда требуется целое число размером с регистр процессора (sizeof(void))\nИспользуйте ptrdiff_t для обозначения разности между двумя указателями (e.g. std::distance)\n\nМакросы\n\n\n                  \n                  Предупреждение \n                  \n                \nИзбегайте определения макросов. Практически любой функционал макросов можно представить с помощью:\n\ninline-функций\nconstexpr/consteval-функций и переменных\nШаблонных функций и классов\n\n\nИсключением может являться:\n\nМакрос для конверсии в строку (stringify-макрос)\nМакросы для определения платформозависимого кода, который будет раскрываться в разные значения в зависимости от компилятора/системы. Таким образом можно заменять некоторые ключевые слова.\nФункциональные макросы, цель которых - генерация кода (объявление функций, классов и т.д), которые невозможно заменить шаблонами.\n\nЕсли вы все же решили объявить макрос, то следуйте следующим правилам:\n\nНикогда не определяйте макросы в заголовочных файлах публичного API\nСтарайтесь определять макрос там, где вы его используйте, затем выполняйте #undef\nДавайте макросам уникальные имена, которые гарантированно не приведут к коллизиям.\n\nАльтернативы\nКонстанты\n#define PI 3.14              // 😒 плохо!\n \nconstexpr auto PI = 3.14;    // 😊 хорошо!\nЭта секция будет пополняться в дальнейшем.\nНулевые типы\n\nИспользуйте nullptr для обозначения нулевых указателей\nИспользуйте &#039;\\0&#039; для обозначения null-terminatorа в строках\nИспользуйте std::nullopt для обозначения пустого std::optional&lt;T&gt;\n\n\n\n                  \n                  Замечание \n                  \n                \nНикогда не используйте NULL или 0 для обозначения нулевого указателя.\n\nAuto\nИспользуйте ключевое слово auto для объявления переменных во всех случаях. Это помогает достичь единообразия в кодовой базе и, зачастую, писать меньше кода для явного указания типа.\nЕсли требуется явный тип, то его можно объявить так:\nauto vec = std::vector&lt;int&gt;();\n \nauto const object = Cat();\nЕсли auto ассоциирует себя не с той переменной, которую вы ожидаете (например, в случае с std::vector&lt;bool&gt;), то используйте явное приведение или конструктор:\nauto const flags = std::vector&lt;bool&gt;{true, false, true, false};\n \nauto const first_flag = static_cast&lt;bool&gt;(flags[0]);\nauto const second_flag = bool(flags[1]);\nДля итерации по контейнерам также используйте ключевое слово auto:\nfor(auto num : numbers) // для итерации по значению\n \nfor(auto&amp; word : words) // для итерации по изменяемой ссылке\n \nfor(auto const&amp; v : values) // для итерации по константной ссылке\nАналогичным образом используйте семантику ссылок для объявления переменной ссылочного типа:\nauto vec = std::vector&lt;int&gt;{1, 2, 3, 4};\n \nauto value = vec.at(0);          // значение\nauto&amp; mut_ref = vec.at(1);       // изменяемая ссылка\nauto const&amp; ref = vec.at(2);     // константная ссылка\nauto* ptr = &amp;vec.at(3);          // указатель"},"naming":{"title":"Соглашение по именованию","links":["lang-features"],"tags":["cxx"],"content":"Файлы\nФайлы в С++ должны именоваться в нижнем регистре и могут содержать нижние подчеркивания (_). Это правило также распостраняется и на папки.\n\nФайлы исходного кода должны иметь расширение .cc.\nПубличные заголовочные файлы должны иметь расширение .h.\nПриватные заголовочные файлы могут иметь расширение .h или .hh на ваш выбор.\nПрочие файлы, предназначенные для включения, могут иметь расширение .inc.\nФайлы модулей должны иметь расширение .cppm.\n\nЗачастую, файл исходного кода должен иметь одинаковое имя с ассоциированным заголовочным файлом.\nПример хороших имен файлов:\n\nvery_cute_cat.h/very_cute_cat.cc\nutils.hh/utils.cc\nring_buffer.h/ring_buffer.inc\n\nТипы\nИмена типов (классов, структур, псевдонимов, перечислений) должны быть в PascalCase.\nПример:\nclass MyClass;\nstruct DataHolder;\nenum class BitFlags;\nusing Alias = MyClass;\n\n\n                  \n                  Примечание \n                  \n                \nИсключением может являться тип, который ассоциирован с std/STL/Boost типом. В таком случае имя типа должно быть написано в snake_case-регистре по аналогии с вышеуказанными библиотеками.\n\n\n\n                  \n                  Примечание \n                  \n                \nЭто же правило распостраняется на концепты из С++20.\n\nПеременные и константы\nПеременные должны быть в snake_case. Это распостраняется на:\n\nЛокальные переменные\nЧлены классов\nАргументы функций\n\nПоля классов и структур должны иметь префикс m_, если они являются приватными полями.\nКонстанты должны быть названы в SCREAMING_SNAKE_CASE, то есть иметь все заглавные буквы со словами, разделенными нижними подчеркиваниями.\nПример:\nauto integer_variable = 5;\n \nauto fn(int arg1, int arg2, void* pointer_to_data) -&gt; void;\n \nclass MyClass {\n  private:\n    int m_num1;\n    float m_num2;\n    double m_num3;\n};\n \nconstexpr static auto SPEED_OF_LIGHT = 300&#039;000&#039;000;\nФункции\nФункции следуют тому же правилу, что и локальные переменные - snake_case.\n\n\n                  \n                  Примечание \n                  \n                \nФункции, предназначенные для экспорта в QML, должны соблюдать соглашение по именованию Qt - camelCase.\n\nПример:\nclass Cat {\n  public:\n    auto meow() -&gt; void;\n    auto meow_loudly() -&gt; int;\n};\n \nclass CatWrapper : public QObject {\n  Q_OBJECT\n  \n  public:\n    Q_INVOKABLE void meow();\n    Q_INVOKABLE int meowLoudly();\n};\nПространства имен\nПространства имен должны быть целиком в нижнем регистре и не содержать нижних подчеркиваний и прочих символов.\nПубличные пространства имен должны быть короткими и простыми в написании.\nПеречисления\nПеречисления и их значения должны целиком следовать конвенции PascalCase.\nПример:\nenum class BitFlags {\n  FlagA = 1 &lt;&lt; 0,\n  FlagB = 1 &lt;&lt; 1,\n  FlagC = 1 &lt;&lt; 2\n};\nМакросы\nМакросы - это плохо!\nОднако, если вы все же решили объявить макрос, то допускается 3 варианта именования:\n\nSCREAMING_SNAKE_CASE\nsnake_case\n$leading_dollar_snake_case\n\nПример:\n#define MY_VERY_COOL_MACRO(...)\n \n#define scary_macro_that_scares(...)\n \n#define $even_scarier_macro_that_scares_children_and_adults(...)\nНазвания библиотек\nВаши библиотеки должны называться в соответствии со следующими правилами:\n\nНижний регистр\nМогут содержать цифры\nСлова разделены символом -\n\nПримеры хороших названий:\n\ncute-cat-lib\ncatlib\nradar-mms-library3\n"},"scoping":{"title":"Область видимости","links":[],"tags":["cxx"],"content":"Пространства имен\nЗа редкими исключениями, ваш код должен находиться в пространстве имен.\nХорошее пространство имен содержит:\n\nИмя библиотеки/проекта\nПуть к заголовочному файлу\n\n\n\n                  \n                  Пример \n                  \n                \nЕсли у вас есть заголовочный файл, принадлежащий к библиотеке animals и лежащий в папке include/animals/mammals/cute/cat.h, то идеальным пространством имен будет: animals::mammals::cute.\n\nДиректива using\nНе используйте директиву using в глобальном пространстве имен в заголовках. Вместо этого используйте ее внутри пространства имен, объявленного в заголовке (а еще лучше, внутри функций, в которых необходима )\nДля этого правила есть исключения, но в общем случае оно должно выполняться.\nБезымянные пространства имен\nЕсли функция или класс используется только внутри файла, в котором она объявлена, то хорошим тоном будет поместить ее в безымянное пространство имен, например:\nnamespace {\n\tauto add(int x, int y) -&gt; int { return x + y; }\n}\n \nauto main() {\n\treturn ::add(0, 0);\n}\nВызов этой функции в дальнейшем будет осуществляться с помощью оператора ::.\r\nПодробнее об этом: Stackoverflow\n\n\n                  \n                  Предупреждение \n                  \n                \nНе используйте эту практику в заголовочных файлах.\n\nПрочие замечания\n\nНе используйте inline namespace.\nНе объявляйте ничего в пространстве имен std::.\n\nСтатические функции\nНе нужно помещать статические функции в класс, если они не привязаны логически и семантически к этому классу; не нужно создавать класс только для того, чтобы сгруппировать статические функции. Правильной альтернативой этому будет помещать свободные функции в пространство имен.\nПример:\n/* 😡 плохо */\nclass Math {\n\tstatic auto add(int x, int y) -&gt; int;\n\tstatic auto subtract(int x, int y) -&gt; int;\n};\n \n/* 😊 хорошо */\nnamespace math {\n\t[[nodiscard]] auto add(int x, int y) -&gt; int;\n\t[[nodiscard]] auto subtract(int x, int y) -&gt; int;\n}\n\n\n                  \n                  Примечание \n                  \n                \nИсключением может являться экспорт группы функций для QML, однако в таком случае лучшим решением будет создание класса-обертки для свободных функций.\n\nЛокальные переменные\nПомещайте локальные переменные настолько в обособленной области видимости, насколько это возможно. Соблюдайте принцип RAII (Wikipedia). Никогда не объявляйте переменные без инициализации.\nИспользуйте ключевые слова auto и auto const.  Они запрещают объявление неинициализированных переменных.\nПример 1\n/* 😡 плохо */\nint i;\ni = 1;\n \n/* 😊 хорошо */\nauto const i = 1; \nПример 2\n/* 😡 плохо */\nstd::vector&lt;int&gt; a;\na.push_back(1);\na.push_back(2);\n \n/* 😊 хорошо */\nauto const a = std::vector&lt;int&gt;{1, 2};\nПример 3\n/* 😡 плохо */\nint* a = static_cast&lt;int*&gt;(malloc(1024));\nif(a != nullptr)\n\treturn a;\nreturn make_unexpected(&quot;error allocating 1024 bytes&quot;);\n \n/* 😊 хорошо */\n// область видимости `a` - условие if и его ветви.\nif(auto a = static_cast&lt;int*&gt;(malloc(1024)); a != nullptr) \n\treturn a;\nreturn make_unexpected(&quot;error allocating 1024 bytes&quot;);\nСтатические и локальные для потока переменные\nСтатические переменные должны всегда иметь тривиальный деструктор. Почти всегда из этого правила следует то, что статические переменные должны быть constexpr.\nОбщие паттерны для статических данных\nСтатические строки\nusing namespace std::string_view_literals;\n \nconstexpr auto PROJECT_NAME = &quot;meow&quot;sv;\nСтатические контейнеры (std::map, std::set, etc.)\nЗапрещается использовать стандартные контейнеры в сочетании с ключевым слово static, так как они имеют нетривиальный деструктор.\nВ качестве альтернативы предлагается использовать std::array фиксированного размера, либо пересмотр архитектуры своего кода.\nПо той же причине умные указатели не должны использоваться в сочетании с ключевым словом static.\nСвои типы данных\nДля прочих типов данных в статической памяти выполняется  2 правила:\n\nНаличие constexpr-конструктора\nНаличие тривиального деструктора\n\nЛокальные для потока переменные\nКлючевое слово thread_local должно использоваться только в сочетании с ключевым словом constinit.\nconstinit thread_local auto cat = /* ... */;"}}